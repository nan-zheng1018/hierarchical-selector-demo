# Next.js + React コンポーネント開発手順書

## 概要

このドキュメントは、Next.js プロジェクトでReactコンポーネントを開発する際の詳細な手順を説明します。
コンポーネント開発、Storybook、Jestテストケースの作成まで包括的にカバーしています。

## 目次

1. [プロジェクト構造](#プロジェクト構造)
2. [コンポーネント開発手順](#コンポーネント開発手順)
3. [Storybook セットアップと作成](#storybook-セットアップと作成)
4. [Jest テストケース作成](#jest-テストケース作成)
5. [実装例](#実装例)
6. [ベストプラクティス](#ベストプラクティス)

## プロジェクト構造

```
src/
├── components/
│   ├── ComponentName/
│   │   ├── index.tsx              # メインコンポーネント
│   │   ├── ComponentName.css      # スタイルファイル
│   │   └── types.ts               # 型定義（必要に応じて）
│   └── __tests__/
│       └── ComponentName.test.tsx # テストファイル
├── stories/
│   └── ComponentName.stories.tsx  # Storybook ストーリー
└── app/
    └── component-demo/
        └── page.tsx               # デモページ
```

## コンポーネント開発手順

### Step 1: コンポーネントディレクトリの作成

```bash
mkdir src/components/YourComponent
cd src/components/YourComponent
```

### Step 2: 型定義の設計

まず、コンポーネントで使用する型とインターフェースを定義します。

```typescript
// types.ts（複雑な場合は別ファイル、シンプルな場合はindex.tsx内に記述）
export interface YourComponentProps {
  title: string
  items: Array<{
    id: number
    name: string
    selected?: boolean
  }>
  onSelectionChange?: (selectedItems: number[]) => void
  disabled?: boolean
  className?: string
}
```

### Step 3: メインコンポーネントの実装

```typescript
// index.tsx
'use client'

import React, { useState, useEffect } from 'react'
import './YourComponent.css'

// 型定義
export interface YourComponentProps {
  // プロパティの定義
}

export const YourComponent: React.FC<YourComponentProps> = ({
  // プロパティのデストラクチャリング
}) => {
  // 状態管理
  const [internalState, setInternalState] = useState<StateType>(initialValue)

  // エフェクトフック
  useEffect(() => {
    // 副作用処理
  }, [dependencies])

  // イベントハンドラー
  const handleEvent = (param: ParamType) => {
    // イベント処理ロジック
  }

  // レンダリング
  return (
    <div className="your-component">
      {/* JSX構造 */}
    </div>
  )
}

export default YourComponent
```

### Step 4: スタイルファイルの作成

```css
/* YourComponent.css */

/* コンポーネントのルートクラス */
.your-component {
  /* 基本スタイル */
}

/* 状態に応じたスタイル */
.your-component.disabled {
  /* 無効化時のスタイル */
}

/* 子要素のスタイル */
.your-component .child-element {
  /* 子要素のスタイル */
}

/* レスポンシブ対応 */
@media (max-width: 768px) {
  .your-component {
    /* モバイル用スタイル */
  }
}
```

### Step 5: コンポーネントを使う

```typescript
// src/app/your-component-demo/page.tsx
'use client'

import React, { useState } from 'react'
import YourComponent from '@/components/YourComponent'

export default function YourComponentDemo() {
  const [selectedItems, setSelectedItems] = useState<number[]>([])

  const handleSelectionChange = (items: number[]) => {
    setSelectedItems(items)
    console.log('選択されたアイテム:', items)
  }

  return (
    <div style={{ padding: '20px' }}>
      <h1>YourComponent デモ</h1>
      
      <div style={{ marginBottom: '20px' }}>
        <h2>基本的な使用例</h2>
        <YourComponent
          title="サンプルタイトル"
          items={[
            { id: 1, name: 'アイテム1' },
            { id: 2, name: 'アイテム2' },
            { id: 3, name: 'アイテム3' }
          ]}
          onSelectionChange={handleSelectionChange}
        />
      </div>

      <div>
        <h3>選択状態</h3>
        <pre>{JSON.stringify(selectedItems, null, 2)}</pre>
      </div>
    </div>
  )
}
```

## Storybook セットアップと作成

### Step 1: Storybookの初期化（プロジェクト初回のみ）

```bash
npx storybook@latest init
```

### Step 2: ストーリーファイルの作成

```typescript
// src/stories/YourComponent.stories.tsx
import type { Meta, StoryObj } from '@storybook/react'
import YourComponent from '../components/YourComponent'

const meta: Meta<typeof YourComponent> = {
  title: 'Components/YourComponent',
  component: YourComponent,
  parameters: {
    layout: 'centered',
    docs: {
      description: {
        component: 'YourComponentの説明をここに記述します。'
      }
    }
  },
  tags: ['autodocs'],
  argTypes: {
    title: {
      control: { type: 'text' },
      description: 'コンポーネントのタイトル'
    },
    disabled: {
      control: { type: 'boolean' },
      description: '無効化フラグ'
    },
    onSelectionChange: {
      action: 'selection-changed',
      description: '選択変更時のコールバック関数'
    }
  }
}

export default meta
type Story = StoryObj<typeof meta>

// 基本的なストーリー
export const Default: Story = {
  args: {
    title: 'デフォルトタイトル',
    items: [
      { id: 1, name: 'アイテム1' },
      { id: 2, name: 'アイテム2' },
      { id: 3, name: 'アイテム3' }
    ]
  }
}

// 選択済みアイテムがある場合
export const WithSelectedItems: Story = {
  args: {
    title: '選択済みアイテムあり',
    items: [
      { id: 1, name: 'アイテム1', selected: true },
      { id: 2, name: 'アイテム2' },
      { id: 3, name: 'アイテム3', selected: true }
    ]
  }
}

// 無効化状態
export const Disabled: Story = {
  args: {
    title: '無効化状態',
    items: [
      { id: 1, name: 'アイテム1' },
      { id: 2, name: 'アイテム2' }
    ],
    disabled: true
  }
}

// 空の状態
export const Empty: Story = {
  args: {
    title: '空の状態',
    items: []
  }
}

// 多数のアイテム
export const ManyItems: Story = {
  args: {
    title: '多数のアイテム',
    items: Array.from({ length: 20 }, (_, i) => ({
      id: i + 1,
      name: `アイテム${i + 1}`
    }))
  }
}
```

### Step 3: Storybookの実行

```bash
npm run storybook
```

## Jest テストケース作成

### Step 1: テストファイルの作成

```typescript
// src/components/__tests__/YourComponent.test.tsx
import React from 'react'
import { render, screen, fireEvent, waitFor } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import '@testing-library/jest-dom'
import YourComponent from '../YourComponent'

// モックデータ
const mockItems = [
  { id: 1, name: 'テストアイテム1' },
  { id: 2, name: 'テストアイテム2' },
  { id: 3, name: 'テストアイテム3' }
]

// 基本的な描画テスト
describe('YourComponent', () => {
  it('正常に描画される', () => {
    render(
      <YourComponent
        title="テストタイトル"
        items={mockItems}
      />
    )

    expect(screen.getByText('テストタイトル')).toBeInTheDocument()
    expect(screen.getByText('テストアイテム1')).toBeInTheDocument()
    expect(screen.getByText('テストアイテム2')).toBeInTheDocument()
    expect(screen.getByText('テストアイテム3')).toBeInTheDocument()
  })

  // プロパティのテスト
  it('titleプロパティが正しく表示される', () => {
    const testTitle = 'カスタムタイトル'
    render(
      <YourComponent
        title={testTitle}
        items={mockItems}
      />
    )

    expect(screen.getByText(testTitle)).toBeInTheDocument()
  })

  // イベントハンドリングのテスト
  it('アイテムクリック時にコールバックが呼ばれる', async () => {
    const mockCallback = jest.fn()
    const user = userEvent.setup()

    render(
      <YourComponent
        title="テストタイトル"
        items={mockItems}
        onSelectionChange={mockCallback}
      />
    )

    const firstItem = screen.getByText('テストアイテム1')
    await user.click(firstItem)

    expect(mockCallback).toHaveBeenCalledWith([1])
  })

  // 状態変化のテスト
  it('複数アイテムの選択・解除が正しく動作する', async () => {
    const mockCallback = jest.fn()
    const user = userEvent.setup()

    render(
      <YourComponent
        title="テストタイトル"
        items={mockItems}
        onSelectionChange={mockCallback}
      />
    )

    // 最初のアイテムを選択
    await user.click(screen.getByText('テストアイテム1'))
    expect(mockCallback).toHaveBeenLastCalledWith([1])

    // 2番目のアイテムを追加選択
    await user.click(screen.getByText('テストアイテム2'))
    expect(mockCallback).toHaveBeenLastCalledWith([1, 2])

    // 最初のアイテムを解除
    await user.click(screen.getByText('テストアイテム1'))
    expect(mockCallback).toHaveBeenLastCalledWith([2])
  })

  // エラーハンドリングのテスト
  it('空のitemsが渡された場合でもエラーが発生しない', () => {
    render(
      <YourComponent
        title="テストタイトル"
        items={[]}
      />
    )

    expect(screen.getByText('テストタイトル')).toBeInTheDocument()
  })

  // 無効化状態のテスト
  it('disabledプロパティが true の場合、クリックイベントが無効になる', async () => {
    const mockCallback = jest.fn()
    const user = userEvent.setup()

    render(
      <YourComponent
        title="テストタイトル"
        items={mockItems}
        onSelectionChange={mockCallback}
        disabled={true}
      />
    )

    await user.click(screen.getByText('テストアイテム1'))
    expect(mockCallback).not.toHaveBeenCalled()
  })

  // スタイルのテスト
  it('カスタムクラスが正しく適用される', () => {
    const customClass = 'custom-class'
    render(
      <YourComponent
        title="テストタイトル"
        items={mockItems}
        className={customClass}
      />
    )

    const component = screen.getByText('テストタイトル').closest('.your-component')
    expect(component).toHaveClass(customClass)
  })

  // 非同期処理のテスト（該当する場合）
  it('非同期データロードが正しく処理される', async () => {
    const asyncItems = Promise.resolve(mockItems)
    
    render(
      <YourComponent
        title="テストタイトル"
        items={[]}
        asyncData={asyncItems}
      />
    )

    await waitFor(() => {
      expect(screen.getByText('テストアイテム1')).toBeInTheDocument()
    })
  })
})

// スナップショットテスト
describe('YourComponent スナップショット', () => {
  it('基本的な描画のスナップショット', () => {
    const { container } = render(
      <YourComponent
        title="テストタイトル"
        items={mockItems}
      />
    )

    expect(container.firstChild).toMatchSnapshot()
  })
})
```

### Step 2: テストの実行

```bash
# 全テストを実行
npm test

# 特定のファイルのテストを実行
npm test YourComponent.test.tsx

# ウォッチモードでテストを実行
npm test -- --watch

# カバレッジレポートを生成
npm test -- --coverage
```

## 実装例

### 実際のコンポーネント例（SimpleSelector）

```typescript
// src/components/SimpleSelector/index.tsx
'use client'

import React, { useState, useEffect } from 'react'
import { Checkbox } from '@mui/material'
import './SimpleSelector.css'

export interface SelectorItem {
  id: number
  label: string
  disabled?: boolean
}

export interface SimpleSelectorProps {
  title: string
  items: SelectorItem[]
  selectedIds?: number[]
  onSelectionChange?: (selectedIds: number[]) => void
  multiSelect?: boolean
  disabled?: boolean
  className?: string
}

export const SimpleSelector: React.FC<SimpleSelectorProps> = ({
  title,
  items,
  selectedIds = [],
  onSelectionChange,
  multiSelect = true,
  disabled = false,
  className = ''
}) => {
  const [internalSelection, setInternalSelection] = useState<number[]>(selectedIds)

  useEffect(() => {
    setInternalSelection(selectedIds)
  }, [selectedIds])

  const handleItemToggle = (itemId: number) => {
    if (disabled) return

    let newSelection: number[]
    
    if (multiSelect) {
      newSelection = internalSelection.includes(itemId)
        ? internalSelection.filter(id => id !== itemId)
        : [...internalSelection, itemId]
    } else {
      newSelection = internalSelection.includes(itemId) ? [] : [itemId]
    }

    setInternalSelection(newSelection)
    onSelectionChange?.(newSelection)
  }

  return (
    <div className={`simple-selector ${disabled ? 'disabled' : ''} ${className}`}>
      <h3 className="selector-title">{title}</h3>
      <div className="items-container">
        {items.map((item) => (
          <div 
            key={item.id}
            className={`selector-item ${internalSelection.includes(item.id) ? 'selected' : ''} ${item.disabled ? 'item-disabled' : ''}`}
            onClick={() => handleItemToggle(item.id)}
          >
            <Checkbox
              checked={internalSelection.includes(item.id)}
              disabled={disabled || item.disabled}
              size="small"
            />
            <span className="item-label">{item.label}</span>
          </div>
        ))}
      </div>
    </div>
  )
}

export default SimpleSelector
```

## ベストプラクティス

### 1. コンポーネント設計

- **単一責任の原則**: 1つのコンポーネントは1つの責任のみを持つ
- **再利用性**: プロパティで動作をカスタマイズ可能にする
- **型安全性**: TypeScriptの型定義を活用する

### 2. プロパティ設計

```typescript
// 良い例：明確で型安全なプロパティ
interface GoodProps {
  title: string                          // 必須プロパティ
  items: Array<{id: number, name: string}>  // 構造化されたデータ
  onSelectionChange?: (ids: number[]) => void  // オプショナルコールバック
  variant?: 'primary' | 'secondary'      // 限定された値
  disabled?: boolean                     // ブール値はオプショナル
}

// 悪い例：曖昧で型安全でないプロパティ
interface BadProps {
  data: any                             // any型は避ける
  callback: Function                    // 具体的でない関数型
  config: object                        // 構造が不明
}
```

### 3. 状態管理

```typescript
// 内部状態と外部制御の両方をサポート
const [internalState, setInternalState] = useState(props.initialValue ?? defaultValue)

useEffect(() => {
  // 外部からの変更を内部状態に反映
  if (props.controlledValue !== undefined) {
    setInternalState(props.controlledValue)
  }
}, [props.controlledValue])
```

### 4. エラーハンドリング

```typescript
// プロパティの検証
useEffect(() => {
  if (items.length === 0) {
    console.warn('SimpleSelector: items プロパティが空です')
  }
}, [items])

// 安全なアクセス
const safeCallback = useCallback((value: any) => {
  try {
    onCallback?.(value)
  } catch (error) {
    console.error('コールバック実行エラー:', error)
  }
}, [onCallback])
```

### 5. パフォーマンス最適化

```typescript
// useMemo でコストの高い計算をメモ化
const processedItems = useMemo(() => {
  return items.filter(item => item.visible)
               .sort((a, b) => a.order - b.order)
}, [items])

// useCallback でコールバック関数をメモ化
const handleItemClick = useCallback((id: number) => {
  // クリック処理
}, [dependency1, dependency2])
```

### 6. アクセシビリティ

```typescript
// ARIA属性の追加
<div 
  role="listbox"
  aria-label={title}
  aria-multiselectable={multiSelect}
>
  {items.map(item => (
    <div 
      key={item.id}
      role="option"
      aria-selected={isSelected(item.id)}
      tabIndex={0}
      onKeyDown={handleKeyDown}
    >
      {item.label}
    </div>
  ))}
</div>
```

## まとめ

このガイドに従って開発することで：

1. **保守性の高いコンポーネント**が作成できます
2. **Storybookによる視覚的なテスト**が可能になります
3. **Jestによる自動テスト**で品質を保証できます
4. **型安全性**により開発時エラーを削減できます
5. **再利用性**の高いコンポーネントライブラリを構築できます

定期的にこの手順書を見直し、プロジェクトの成長に合わせてアップデートしてください。
